package com.zhongjia.subtitlefusion.ffmpeg.ass;

import com.zhongjia.subtitlefusion.config.AppProperties;
import com.zhongjia.subtitlefusion.model.SubtitleFusionV2Request;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;

/**
 * 负责将 V2 请求转换为 ASS 字幕文件。
 */
@Component
public class AssSubtitleFileBuilder {

    @Autowired
    private AppProperties props;
    @Autowired
    private AssEffectStrategyResolver strategyResolver;

    public Path buildAssFile(SubtitleFusionV2Request.SubtitleInfo subtitleInfo, Path videoPath) throws Exception {
        if (subtitleInfo == null || subtitleInfo.getCommonSubtitleInfoList() == null || subtitleInfo.getCommonSubtitleInfoList().isEmpty()) {
            return null;
        }

        String fontFamily = props.getRender() != null && props.getRender().getFontFamily() != null
                ? props.getRender().getFontFamily()
                : "Microsoft YaHei";

        List<String> lines = new ArrayList<>();
        // Header
        lines.add("[Script Info]");
        lines.add("; Script generated by subtitle-fusion");
        lines.add("ScriptType: v4.00+");
        lines.add("WrapStyle: 2");
        lines.add("ScaledBorderAndShadow: yes");
        // 固定脚本分辨率，便于字号与视频建立稳定映射（后续可改为探测实际分辨率）
        int playX = 1920;
        int playY = 1080;
        try {
            if (videoPath != null) {
                int[] wh = com.zhongjia.subtitlefusion.util.MediaProbeUtils.probeVideoResolution(videoPath);
                playX = wh[0]; playY = wh[1];
            }
        } catch (Exception ignore) {}
        lines.add("PlayResX: " + playX);
        lines.add("PlayResY: " + playY);
        lines.add("");

        // Styles（一个基础样式）
        // 根据实际分辨率计算基础字号（按视频高度的 4%），并允许配置覆盖
        int baseDefault = 28;
        int baseFontSize = baseDefault;
        try {
            baseDefault = Math.max(18, Math.round(playY * 0.04f));
            baseFontSize = baseDefault;
        } catch (Exception ignore) {}
        if (props.getRender() != null) {
            Integer fontSizePx = props.getRender().getFontSizePx();
            Float fontScale = props.getRender().getFontScale();
            Integer minFontSizePx = props.getRender().getMinFontSizePx();
            if (fontSizePx != null && fontSizePx > 0) {
                baseFontSize = fontSizePx;
            } else if (fontScale != null && fontScale > 0f) {
                baseFontSize = Math.round(baseDefault * fontScale);
            }
            if (minFontSizePx != null && minFontSizePx > 0) {
                baseFontSize = Math.max(baseFontSize, minFontSizePx);
            }
        }

        lines.add("[V4+ Styles]");
        lines.add("Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding");

        // 计算垂直位置：支持 bottom/top/center 锚点与边距配置
        int align = 2; // bottom-center
        int marginV = Math.max(30, Math.round(playY * 0.25f)); // 默认距底部约 25%
        try {
            if (props.getRender() != null && props.getRender().getVerticalAnchor() != null) {
                String anchor = props.getRender().getVerticalAnchor();
                if ("top".equalsIgnoreCase(anchor)) {
                    align = 8; // top-center
                    Integer px = props.getRender().getMarginTopPx();
                    Float pct = props.getRender().getMarginTopPercent();
                    marginV = (px != null && px >= 0) ? px : (pct != null && pct >= 0 ? Math.round(playY * (pct / 100f)) : Math.max(30, Math.round(playY * 0.25f)));
                } else if ("center".equalsIgnoreCase(anchor)) {
                    align = 6; // middle-center
                    marginV = 0; // 居中时通常不使用垂直边距
                } else { // bottom 或其它
                    align = 2; // bottom-center
                    Integer px = props.getRender().getMarginBottomPx();
                    Float pct = props.getRender().getMarginBottomPercent();
                    marginV = (px != null && px >= 0) ? px : (pct != null && pct >= 0 ? Math.round(playY * (pct / 100f)) : Math.max(30, Math.round(playY * 0.25f)));
                }
            }
        } catch (Exception ignore) {}

        lines.add("Style: Default," + fontFamily + "," + baseFontSize + ",&H00FFFFFF,&H0000FFFF,&H00000000,&H64000000,0,0,0,0,100,100,0,0,1,2,1," + align + ",20,20," + marginV + ",1");
        lines.add("");

        // Events
        lines.add("[Events]");
        lines.add("Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text");

        // 重叠检测与错位：为行分配“槽位”（lane）
        Map<SubtitleFusionV2Request.CommonSubtitleInfo, Integer> laneMap = assignLanes(subtitleInfo.getCommonSubtitleInfoList());
        int laneCount = 0;
        for (Integer v : laneMap.values()) laneCount = Math.max(laneCount, v != null ? v + 1 : 0);
        int lineGapPx = Math.max( (int)Math.round(baseFontSize * 1.35f), Math.round(playY * 0.03f) );

        for (SubtitleFusionV2Request.CommonSubtitleInfo line : subtitleInfo.getCommonSubtitleInfoList()) {
            AssEffectStrategy strategy = strategyResolver.resolve(line);
            String overrideTags = strategy.buildOverrideTags(line, playX, playY);
            String text = strategy.rewriteTextWithKeywords(line);
            int lane = laneMap.getOrDefault(line, 0);

            String start = normalizeToAssTime(line.getStartTime());
            String end = normalizeToAssTime(line.getEndTime());
            int eventMarginV = 0;
            boolean hasPosOrMove = overrideTags.contains("\\pos") || overrideTags.contains("\\move");
            if (align == 2 || align == 8) {
                // 底部或顶部锚点：使用事件级 MarginV 进行错位（在样式 marginV 基础上叠加）
                eventMarginV = marginV + lane * lineGapPx;
            } else if (align == 6 && !hasPosOrMove && laneCount > 1) {
                // 居中锚点：无法用 MarginV，注入 pos 进行垂直错位（仅在不与其它位置动画冲突时）
                int x = playX / 2;
                int yCenter = playY / 2;
                int totalHeight = (laneCount - 1) * lineGapPx;
                int y = yCenter - totalHeight / 2 + lane * lineGapPx;
                overrideTags = "\\pos(" + x + "," + y + ")" + overrideTags;
            }

            String dialogue = "Dialogue: 0," + start + "," + end + ",Default,,0000,0000," + (eventMarginV > 0 ? Integer.toString(eventMarginV) : "0000") + ",,{" + overrideTags + "}" + escapeAssText(text);
            lines.add(dialogue);
        }

        String ts = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        Path tempDir = Paths.get(System.getProperty("java.io.tmpdir"), "subtitle-fusion");
        Files.createDirectories(tempDir);
        Path assPath = tempDir.resolve("subtitle_" + ts + ".ass");
        Files.write(assPath, String.join("\n", lines).getBytes(StandardCharsets.UTF_8));
        return assPath;
    }

    private String escapeAssText(String s) {
        if (s == null) return "";
        // 基础转义：将换行替换为 \N
        return s.replace("\n", "\\N");
    }

    private String normalizeToAssTime(String t) {
        // 支持 "00:00:01.000" / "00:00:01,000" / 纯秒字符串；统一为 H:MM:SS.xx（两位小数，百分秒）
        if (t == null || t.isEmpty()) return "0:00:00.00";
        String s = t.trim();

        try {
            if (s.matches("^\\d+(\\.\\d+)?$")) {
                // 纯秒
                double totalSeconds = Double.parseDouble(s);
                long centiseconds = Math.round(totalSeconds * 100.0);
                long h = centiseconds / (3600L * 100L);
                long rem = centiseconds % (3600L * 100L);
                long m = rem / (60L * 100L);
                long cs = rem % (60L * 100L);
                double sec = cs / 100.0;
                return String.format("%d:%02d:%05.2f", h, m, sec);
            }

            // 替换逗号为点，解析 HH:MM:SS(.ms)
            s = s.replace(',', '.');
            String[] parts = s.split(":");
            if (parts.length >= 3) {
                int h = Integer.parseInt(parts[0]);
                int m = Integer.parseInt(parts[1]);
                double secPart = Double.parseDouble(parts[2]);
                double totalSeconds = h * 3600.0 + m * 60.0 + secPart;
                long centiseconds = Math.round(totalSeconds * 100.0);
                long outH = centiseconds / (3600L * 100L);
                long rem = centiseconds % (3600L * 100L);
                long outM = rem / (60L * 100L);
                long cs = rem % (60L * 100L);
                double outS = cs / 100.0;
                return String.format("%d:%02d:%05.2f", outH, outM, outS);
            }
        } catch (Exception ignore) {
            // fallthrough
        }

        return "0:00:00.00";
    }

    /**
     * 为重叠字幕分配“槽位”，同一时刻不同槽位用于错位展示。
     * 简化策略：按开始时间排序，最早结束可复用的槽位优先；每条记录分配整数 lane，从 0 起。
     */
    private Map<SubtitleFusionV2Request.CommonSubtitleInfo, Integer> assignLanes(List<SubtitleFusionV2Request.CommonSubtitleInfo> list) {
        Map<SubtitleFusionV2Request.CommonSubtitleInfo, Integer> laneMap = new IdentityHashMap<>();
        if (list == null || list.isEmpty()) return laneMap;
        List<SubtitleFusionV2Request.CommonSubtitleInfo> items = new ArrayList<>(list);
        Collections.sort(items, Comparator.comparingInt(a -> parseMsSafe(a.getStartTime())));

        // 维护每个 lane 的最早可用时间（上一条字幕的结束）
        List<Integer> laneAvailableAt = new ArrayList<>();
        for (SubtitleFusionV2Request.CommonSubtitleInfo it : items) {
            int s = parseMsSafe(it.getStartTime());
            int e = Math.max(s + 200, parseMsSafe(it.getEndTime()));
            int chosen = -1;
            for (int i = 0; i < laneAvailableAt.size(); i++) {
                if (laneAvailableAt.get(i) <= s) { chosen = i; break; }
            }
            if (chosen < 0) {
                chosen = laneAvailableAt.size();
                laneAvailableAt.add(e);
            } else {
                laneAvailableAt.set(chosen, e);
            }
            laneMap.put(it, chosen);
        }
        return laneMap;
    }

    private int parseMsSafe(String t) {
        try {
            if (t == null || t.trim().isEmpty()) return 0;
            String s = t.trim().replace(',', '.');
            if (s.matches("^\\d+(\\.\\d+)?$")) {
                double sec = Double.parseDouble(s);
                return (int) Math.round(sec * 1000.0);
            }
            String[] parts = s.split(":");
            if (parts.length < 3) return 0;
            int h = Integer.parseInt(parts[0]);
            int m = Integer.parseInt(parts[1]);
            double sec = Double.parseDouble(parts[2]);
            return (int) Math.round(((h * 3600) + (m * 60) + sec) * 1000.0);
        } catch (Exception ignore) {
            return 0;
        }
    }
}


